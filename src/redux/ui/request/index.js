import { createSlice } from "@reduxjs/toolkit";

export const requestsSlice = createSlice({
    name: "requests",
    initialState: {},
    selectors: {
        selectRequestStatusById: (state, id) => state[id] || "idle",
    },
    extraReducers: (builder) => builder
        .addMatcher(
            ({ type }) => type.endsWith("/pending"),
            (state, { meta }) => {
                state[meta.requestId] = "pending";
            }
        )
        .addMatcher(
            ({ type }) => type.endsWith("/fulfilled"),
            (state, { meta }) => {
                state[meta.requestId] = "fulfilled";
            }
        )
        .addMatcher(
            ({ type }) => type.endsWith("/rejected"),
            (state, { meta }) => {
                state[meta.requestId] = "rejected";
            }
        ),
});

export const { selectRequestStatusById } = requestsSlice.selectors

// ЧТО ПРОИСХОДИТ НА ЭТОЙ СТРАНИЦЕ?

// 3. Дополнительные редюсеры (extraReducers):

// В этой части мы определяем дополнительные редюсеры для обработки состояний, связанных с асинхронными действиями (например, с использованием createAsyncThunk). Это делается через метод builder, который предоставляет интуитивные методы для обработки различных действий.

// 4. Добавление матчеров для обработки статусов запросов:
// Здесь к extraReducers добавляются три матчера, которые слушают типы действий, заканчивающихся на /pending, /fulfilled и /rejected.

// - /pending:

// Этот матчер активируется, когда действие имеет тип, заканчивающийся на /pending. В этом случае состояние обновляется: создается или обновляется свойство объекта state с ключом meta.requestId и устанавливается значение "pending". Это означает, что запрос находится в процессе выполнения.

// - /fulfilled:

// Этот матчер реагирует на действий, заканчивающиеся на /fulfilled. Оно обновляет состояние, устанавливая значение для meta.requestId на "fulfilled", что говорит о том, что запрос успешно завершен.

// - /rejected:

// Этот матчер срабатывает при действиях, заканчивающихся на /rejected. В этом случае состояние обновляется: устанавливается значение "rejected" для meta.requestId, что говорит о том, что запрос завершился с ошибкой.

// ### Общая логика

// В результате, данный код создает срез состояния, который отслеживает состояние асинхронных запросов в приложении. При помощи матчеров мы регистрируем, когда запросы находятся в процессе выполнения, успешно выполнены или завершились с ошибкой. Состояние этих запросов сохраняется в объекте, ключом которого является requestId, что позволяет удобно управлять состоянием запросов в приложении. 

// Это может быть особенно полезно в ситуациях, когда ваше приложение отправляет несколько параллельных запросов и вам нужно знать, какие из них все еще выполняются, а какие уже завершились.





// extraReducers и builder — это ключевые концепции в Redux Toolkit, которые упрощают управление асинхронными действиями и состоянием приложения. Давайте подробнее разберем каждую из этих составляющих.

// ### Что такое extraReducers

// extraReducers — это свойство, которое используется в функции createSlice для обработки действий, которые не относятся непосредственно к действиям, создаваемым в вашем срезе состояния. Это особенно полезно в контексте асинхронных действий, таких как те, которые создаются с помощью createAsyncThunk.

// #### Зачем нужен extraReducers?

// 1. Обработка асинхронных действий: Позволяет вам добавлять обработчики действий для асинхронных операций, таких как запросы к API, в срез состояния.
// 2. Гибкость: Вы можете реагировать на действия, которые были созданы вне вашего среза, позволяя вам более эффективно управлять состоянием приложения.
// 3. Организация кода: Разделение логики обработки асинхронных действий от синхронных позволяет улучшить читаемость и поддержку кода.

// ### Что такое builder

// builder — это объект, который предоставляется функции extraReducers в качестве аргумента. Он предоставляет методы для добавления различных обработчиков действий (или матчеров) для управления состоянием.
